<?php declare(strict_types=1);

namespace Paneon\PhpToTypeScript\Parser;

class DeclareInterface
{
    /** @var DeclareInterfaceProperty[] */
    protected array $properties = [];

    protected string $prefix = '';
    protected string $suffix = '';
    protected int $indent = 2;
    protected bool $useType = false;
    protected bool $export = false;

    /** @var array<string, string> Type name => import path */
    protected array $imports = [];

    public function __construct(
        protected string $name
    ) {
    }

    public function addProperty(DeclareInterfaceProperty $property)
    {
        if ($this->indent) {
            $property->setIndentSize($this->indent);
        }
        if ($this->prefix) {
            $property->setPrefix($this->prefix);
        }
        if ($this->suffix) {
            $property->setSuffix($this->suffix);
        }

        $this->properties[] = $property;
    }

    public function __toString(): string
    {
        $output = "/* This file was automatically generated by the typescript:generate command. */\n";

        // Add import statements
        $importStatements = $this->generateImportStatements();
        if ($importStatements !== '') {
            $output .= $importStatements . "\n\n";
        }

        // Build interface body
        $interfaceBody = '';
        $lastKey = count($this->properties) - 1;

        foreach ($this->properties as $key => $property) {
            $interfaceBody .= $property->__toString();

            if ($key !== $lastKey) {
                $interfaceBody .= PHP_EOL;
            }
        }

        $exportKeyword = $this->export ? 'export ' : '';
        $name = $this->getName();
        $declaration = $this->useType ? "type {$name} =" : "interface {$name}";
        $closingBrace = $this->useType ? '};' : '}';

        $output .= "{$exportKeyword}{$declaration} {\n{$interfaceBody}\n{$closingBrace}";

        return $output;
    }

    protected function generateImportStatements(): string
    {
        if (empty($this->imports)) {
            return '';
        }

        $statements = [];
        foreach ($this->imports as $typeName => $importPath) {
            $importName = $this->prefix . $typeName . $this->suffix;
            $statements[] = "import { {$importName} } from '{$importPath}';";
        }

        return implode("\n", $statements);
    }

    /**
     * @return string
     */
    public function getName(): string
    {
        return $this->prefix . $this->name . $this->suffix;
    }

    public function setIndent(int $indent): DeclareInterface
    {
        $this->indent = $indent;
        return $this;
    }

    public function setPrefix(string $prefix): DeclareInterface
    {
        $this->prefix = $prefix;
        return $this;
    }

    public function setSuffix(string $suffix): DeclareInterface
    {
        $this->suffix = $suffix;
        return $this;
    }

    public function setUseType(bool $useType): DeclareInterface
    {
        $this->useType = $useType;
        return $this;
    }

    public function setExport(bool $export): DeclareInterface
    {
        $this->export = $export;
        return $this;
    }

    /**
     * Add an import statement for a type.
     *
     * @param string $typeName The type name (without prefix/suffix)
     * @param string $importPath The import path (e.g., './ProductDTO')
     */
    public function addImport(string $typeName, string $importPath): DeclareInterface
    {
        $this->imports[$typeName] = $importPath;
        return $this;
    }

    /**
     * Set multiple imports at once.
     *
     * @param array<string, string> $imports Type name => import path
     */
    public function setImports(array $imports): DeclareInterface
    {
        $this->imports = $imports;
        return $this;
    }

    /**
     * Get all non-primitive types referenced by properties.
     *
     * @return string[] List of unique type names (without prefix/suffix)
     */
    public function getReferencedTypes(): array
    {
        $types = [];
        foreach ($this->properties as $property) {
            $types = array_merge($types, $property->getReferencedTypes());
        }
        return array_unique($types);
    }
}
